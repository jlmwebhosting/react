/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks static-only
 * @providesModule ReactContainer
 */

"use strict";

var ReactInstanceHandles = require('ReactInstanceHandles');
var ReactID = require('ReactID');

var createUniqueID = require('createUniqueID');
var invariant = require('invariant');

var REACT_CONTAINER_ID_PREFIX = 'reactContainer';

var containerCache = {};

/**
 * Get a container by its ID.
 * @param {string} id ID to look for
 * @return {DOMElement} the container
 */
function getContainerByID(id) {
  return containerCache[id];
}

function requireValidContainerNode(container) {
  invariant(
    container && container.nodeType === 1,
    'Target container is not a DOM element.'
  );
}

/**
 * @return {string} A fresh autogenerated string
 */
function createContainerID() {
  return REACT_CONTAINER_ID_PREFIX + createUniqueID()
}

/**
 * In order to abstract the DOM we pass around IDs instead of actual DOMElement
 * instances. Sometimes they aren't mounted in the DOM and we need to hold on
 * to the actual references since we can't directly look them up by IDs. In
 * these situations we put them in a temporary cache. Since container nodes are
 * not managed by React we have no guarantee what the user will do with them, so
 * we want to hold on to this reference for as little as possible (perhaps the
 * user removes it from the DOM without unmounting, for example). We use this
 * method to ensure that the dangling reference is removed.
 *
 * @param {DOMElement} container Container to reference
 * @param {function} cb Callback to call which receives the container ID
 */
function performWithCachedContainer(container, cb) {
  var containerID = createContainerID();
  containerCache[containerID] = container;
  try {
    cb(containerID);
  } catch (e) {
    // IE8 needs catch w/ finally
    throw e;
  } finally {
    containerCache[containerID] = null;
  }
}

/**
 * @param {DOMElement} container DOM element that may contain a React component
 * @return {*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  requireValidContainerNode(container);
  return container.firstChild;
}

/**
 * @param {DOMElement} container DOM element that may contain a React component.
 * @return {?string} A "reactRoot" ID, if a React component is rendered.
 */
function getReactRootID(container) {
  var rootElement = getReactRootElementInContainer(container);
  return rootElement && ReactID.getID(rootElement);
}

/**
 * @param {DOMElement} container DOM element that may contain a React component.
 * @return {boolean} If the container contains markup generated by React
 */
function hasReactMarkup(container) {
  var reactRootElement = getReactRootElementInContainer(container);
  return (
    !!reactRootElement &&
      ReactInstanceHandles.isRenderedByReact(reactRootElement)
  );
}

module.exports = {
  getReactRootID: getReactRootID,
  hasReactMarkup: hasReactMarkup,
  performWithCachedContainer: performWithCachedContainer,
  getContainerByID: getContainerByID
};
